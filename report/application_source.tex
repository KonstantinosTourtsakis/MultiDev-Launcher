






\section{Ο κώδικας του λογισμικού}

Όπως αναφέρθηκε στην εισαγωγή το παρόν πρόγραμμα έχει γραφεί σε C++. Σκοπός
είναι η δημιουργία μιας desktop εφαρμογής σε Qt6 περιβάλλον η οποία δεν
θα υλοποιεί τις ανάγκες της εφαρμογής και θα αξιοποιεί τους πόρους του
συστήματος για καλύτερες αποδόσεις. Στην συνέχεια θα περιγραφεί ο τρόπος
με τον οποίο λειτουργεί η εφαρμογή αναφέροντας τις σημαντικότερες διαδικασίες
που αναγράφονται σε κώδικα και εξηγούν πως φτάνουμε στο τελικό αποτέλεσμα
που είδαμε προηγουμένως.


\section{Η συνάρτηση main}
Κάθε πρόγραμμα γραμμένο σε C++ ξεκινάει με την συνάρτηση main να αποτελεί το
σημείο εκκίνησης του προγράμματος. Επομένως αξίζει να δούμε αναλυτικότερα τι
συμβαίνει σε αυτό το κομμάτι του κώδικα για να μπορέσουμε να κατανοήσουμε
καλύτερα την ροή και τις ενέργειες του προγράμματος.

\begin{lstlisting}[language=C++, style=cppstyle]
int main(int argc, char* argv[]) 
{
    QApplication app(argc, argv);
    
    ApplicationExplorer explorer(app);
    explorer.setWindowTitle("P2019140 - Konstantinos Tourtsakis");
    explorer.setWindowFlags(Qt::WindowCloseButtonHint | Qt::FramelessWindowHint);
    explorer.resize(800, 600);
    
    // Storing screen resolution
    screen_width = GetSystemMetrics(SM_CXSCREEN);
    screen_height = GetSystemMetrics(SM_CYSCREEN);
    
    explorer.CreateUI();
    
    VirtualKeyboard QKeyboard;
    
    //QKeyboard.setWindowFlags(Qt::WindowCloseButtonHint | Qt::FramelessWindowHint);
    explorer.QKeyboard = &QKeyboard;
    

    explorer.showMaximized();
    return app.exec();
}
\end{lstlisting}

Αρχικά δημιουργείται το αντικείμενο της εφαρμογής που δέχεται τα arguments με τα οποία εκτελέστηκε.
Στην συνέχεια δημιουργείται ένα αντικείμενο τύπου ApplicationExplorer. Το αντικείμενο αυτό αποτελεί
το βασικό παράθυρο της εφαρμογής το οποίο κληρονομεί την κλάση QWidget και χτίζει τα αντικείμενα της
γραφικής διεπαφής. Στην συνέχεια προστίθενται ορισμένα flags στο παράθυρο της εφαρμογής. Μετά αποθηκεύονται
οι διαστάσεις της οθόνης του χρήστη σε global μεταβλητές οι οποίες θα χρησιμεύσουν στην προσαρμογή των
διαστάσεων των στοιχείων της γραφικής διεπαφής ανάλογα με τις διαστάσεις της οθόνης. Μετά ακολουθεί η
δημιουργία των γραφικών στοιχείων καλώντας την μέθοδο CreateUI. Η εφαρμογή συνεχίζει με την δημιουργία
ενός ακόμη αντικειμένου. Αυτήν την φορά η κλάση QWidget κληρονομείται από την κλάση VirtualKeyboard
η οποία δημιουργεί και διαχειρίζεται το παράθυρο του εικονικού πληκτρολογίου. Στην συνέχεια δημιουργείται
αντίγραφο της θέσης μνήμης του αντικειμένου αυτού σε μια μεταβλητή της κλάσης του αρχικού παραθύρου με
σκοπό την επικοινωνία μεταξύ των δύο παραθύρων της εφαρμογής κατά την περιήγηση του χρήστη. Τέλος γίνεται
κλήση για προβολή του βασικού παραθύρου της εφαρμογής με τις μέγιστες διαστάσεις παραθύρου και μετά
εκτελείται η επανάληψη της Qt6 εφαρμογής. 


\section{Η κλάση ApplicationExplorer}


Μια εφαρμογή που αξιοποιεί τo Qt6 περιλαμβάνει αντικείμενα διαφόρων τύπων ώστε να
μπορέσει να λειτουργήσει. Όπως τα περισσότερα στοιχεία της εφαρμογής, έτσι και το
παράθυρο που δημιουργείται για να φιλοξενήσει την γραφική διεπαφή της είναι ένα αντικείμενο. 
Στην προκειμένη περίπτωση κληρονομείται η κλάση QWidget και στην συνέχεια χρησιμοποιείται 
ως βάση για την υλοποίηση της εφαρμογής. Παρακάτω βλέπουμε τον ορισμό των χαρακτηριστικών
της κλάσης και 


\begin{lstlisting}[language=C++, style=cppstyle]

\end{lstlisting}





\subsection{Ο constructor}
Παρακάτω βλέπουμε την υλοποίηση του constructor της εφαρμογής στον οποίο δημιουργείται 
το χρονόμετρο με το οποίο εκτελείται η διεργασία περιήγησης του χειριστηρίου βιντεοπαιχνιδιών.

\begin{lstlisting}[language=C++, style=cppstyle]
class ApplicationExplorer : public QWidget
{
    ApplicationExplorer(QApplication& app, QWidget* parent = nullptr) : QWidget(parent), app(app)
    {
        // Controller task loop - Perform task constantly
        timer = new QTimer(this);
        connect(timer, &QTimer::timeout, this, &ApplicationExplorer::TaskGamepadConnection);
        timer->start();

    }
};
\end{lstlisting}



\subsection{Η μέθοδος LoadAppData}
Η μέθοδος LoadAppData είναι υπεύθυνη για την αρχικοποίηση του προγράμματος. Τα
δεδομένα που διαχειρίζεται η μέθοδος αυτή είναι ανεξάρτητα από την δραστηριότητα
του χρήστη και φορτώνονται κατά την εκκίνηση της εφαρμογής. Επομένως έχει να 
κάνει με δεδομένα που το πρόγραμμα θα τροποποιήσει το ίδιο κατά την εκτέλεση. 
Ένα από αυτά είναι η αποθήκευση της κατάστασης του προγράμματος για την ανίχνευση 
της πρώτης εκτέλεσης στην οποία ο χρήστης λαμβάνει ένα εισαγωγικό μήνυμα.



\subsection{Η μέθοδος SaveAppData}
Η μέθοδος SaveAppData διαχειρίζεται τα ίδια δεδομένα με την LoadAppData με την μόνη
διαφορά να βρίσκεται στην λειτουργία της. Όπως είναι προφανές, σκοπός της είναι η
αποθήκευση των δεδομένων αυτών.

\subsection{Η μέθοδος LoadProfile}
Η μέθοδος LoadProfile επίσης αρχικοποιεί το πρόγραμμα κατά την εκκίνηση. Όμως η διαφορά
με την LoadAppData είναι πως στην περίπτωση αυτή γίνεται φόρτωση δεδομένων που αφορούν
την εμπειρία του κάθε χρήστη και όχι του προγράμματος. Επομένως, ενώ η μέθοδος LoadAppData
φορτώνει τα ίδια δεδομένα για όλους τους χρήστες, η LoadProfile θα φορτώσει διαφορετικές
τιμές ανάλογα με τις ενέργειες του κάθε χρήστη.

\subsection{Η μέθοδος SaveProfile}
Η μέθοδος SaveProfile είναι η αντίστοιχη της SaveAppData. Σκοπός της είναι η αποθήκευση
των δεδομένων που διαχειρίζεται η LoadProfile.


\subsection{Η μέθοδος OnApplicationExit}
Η μέθοδος αυτή εκτελεί διαδικασίες που πρέπει να πραγματοποιηθούν κατά την έξοδο εκτέλεσης
του προγράμματος. Για παράδειγμα, Η SaveProfile καλείται μέσω αυτής της μεθόδου. Η εκτέλεσή
της γίνεται συνδέοντάς την εφαρμογή και ορίζοντας ως signal το QCoreApplication::aboutToQuit.

\begin{lstlisting}[language=C++, style=cppstyle]
QObject::connect(&app, &QCoreApplication::aboutToQuit, this, &ApplicationExplorer::OnApplicationExit);
\end{lstlisting}

\subsection{Η μέθοδος DirectoryListUpdated}
Η μέθοδος αυτή αρχικά καθαρίζει την λίστα με τις γνωστές εφαρμογές. Καλείται όταν έχει γίνει
κάποια αλλαγή στην λίστα με τα directories και με κάθε προσθήκη ή αφαίρεση directory προσπελάσει
την λίστα για την ενημέρωση των εφαρμογών που είναι γνωστές στο πρόγραμμα. Η λίστα με τα directories
μπορεί να περιλαμβάνει διευθύνσεις σε μεμονωμένα αρχεία. Επομένως γίνεται έλεγχος. Αν το στοιχείο
είναι directory τότε καλείται η μέθοδος ExploreDirectoryFiles με την διεύθυνση του directory. Αν
το στοιχείο είναι αρχείο τότε το προσθέτει στην λίστα εφαρμογών.


\subsection{Η μέθοδος ExploreDirectoryFiles}
Η μέθοδος αυτή δέχεται ως είσοδο ένα directory και στην συνέχεια προσπελάσει όλα
τα στοιχεία που βρίσκονται σε αυτό. Αν το στοιχείο είναι ένα αρχείο τύπου ".exe", ".lnk"
ή ".url" τότε η μέθοδος το προσθέτει στην λίστα εφαρμογών του χρήστη. Αν ένα στοιχείο 
είναι και αυτό directory τότε γίνεται αναδρομική κλήση της μεθόδου.


\subsection{Η μέθοδος UpdateListWidget}
Η μέθοδος UpdateListWidget δέχεται ως είσοδο μια string λίστα που περιλαμβάνει τις
διευθύνσεις με τις εφαρμογές και μια λίστα με τα αντικείμενα που θα δημιουργηθούν
για την προβολή των εφαρμογών αυτών στην γραφική διεπαφή. Κατά την διαδικασία αυτή
γίνονται ενέργειες σχετικά με την ανάκτηση του εικονιδίου της εφαρμογής και τις
ρυθμίσεις του κάθε χρήστη σχετικά με την συμπερίληψη της επέκτασης του αρχείου ή όχι.

\subsection{Η μέθοδος SearchApplication}
Η μέθοδος αυτή εκτελεί αναζήτηση μέσα στις λίστες εφαρμογών. Δέχεται ως είσοδο ένα
input field από το οποίο θα προέλθει η είσοδος της αναζήτησης, την λίστα αντικειμένων
στην οποία προστίθενται οι εφαρμογές ως στοιχεία για προβολή στην γραφική διεπαφή και
την λίστα με τις διευθύνσεις των εφαρμογών που γνωρίζει το πρόγραμμα. Αφού γίνει ενημέρωση
της λίστας εφαρμογών σύμφωνα με την είσοδο της αναζήτησης, γίνεται τελικά κλήση της 
μεθόδου UpdateListWidget για την ενημέρωση της λίστας αντικειμένων που χρησιμοποιεί
η μέθοδος αναζήτησης. 


\subsection{Η μέθοδος ExecuteApplication}
Η μέθοδος αυτή δέχεται ως είσοδο ένα στοιχείο της λίστας αντικειμένων των εφαρμογών
που προβάλλονται στο πρόγραμμα. Αν το αντικείμενο είναι έγκυρο τότε η μέθοδος φροντίζει
για την εκτέλεσή του ανάλογα με την κατάληξη της διεύθυνσης της εφαρμογής. Αμέσως μετά
προσμετρά την εκτέλεση του αρχείου σε ένα QMap με τις δημοφιλείς εφαρμογές που προκύπτουν
από το πλήθος των εκτελέσεων τους.


\subsection{Η μέθοδος UpdatePopularAppsList}
Η μέθοδος UpdatePopularAppsList δημιουργεί μια λίστα από το QMap που αναφέρθηκε στην
μέθοδο ExecuteApplication προηγουμένως. Αυτό που κάνει είναι να ταξινομεί τα αρχεία που
εκτελέστηκαν σε φθίνουσα σειρά. Στην συνέχεια αποθηκεύει τα 10 πιο δημοφιλή αρχεία σε
μια ξεχωριστή string λίστα που στην συνέχεια θα αξιοποιηθεί για την δημιουργία προτάσεων
κατά την αναζήτηση του χρήστη στο input field.


\subsection{Η μέθοδος TaskGamepadConnection}
Η μέθοδος TaskGamepadConnection είναι υπεύθυνη για την διαχείριση του χειριστηρίου βιντεοπαιχνιδιών. 
Μιας και το Qt μας επιτρέπει να δημιουργήσουμε διαδικασίες που εκτελούνται ανά συγκεκριμένα 
χρονικά διαστήματα, η λειτουργικότητα αυτή συνδυάζεται με τον ορισμό ενός μηδενικού χρονικού 
ορίου. Επομένως η μέθοδος αυτή καλείται συνεχώς για να γίνεται έλεγχος συνδεσιμότητάς του
χειριστηρίου. Η μέθοδος αρχικά κάνει έλεγχο για αρχικοποίηση του χειριστηρίου δημιουργώντας ένα 
αντικείμενο τύπου XBOXController και στην συνέχεια εφόσον υπάρχει συνδεδεμένο χειριστήριο τότε 
καλεί μια συνάρτηση ρουτίνας με όνομα ControllerNavigation στην οποία γίνονται οι έλεγχοι για τις 
βασικές εντολές εισόδου που διαθέτει το χειριστήριο. Αυτές αφορούν την κλήση του εικονικού πληκτρολογίου, 
την απενεργοποίηση των λειτουργιών του χειριστηρίου (αποσκοπεί στην χρήση του χειριστηρίου από άλλες 
εφαρμογές όπως βιντεοπαιχνίδια χωρίς το πρόγραμμα να συγκρούεται με αυτές) αλλά και την κλήση μιας 
ακόμη συνάρτησης ρουτίνας στην οποία ελέγχονται οι υπόλοιπες εντολές εισόδου.




\subsection{Η μέθοδος TaskHandleDevicesUICommunication}
Η μέθοδος αυτή είναι υπεύθυνη για την επικοινωνία μεταξύ της εφαρμογής και δύο άλλων συσκευών εισόδου.
Οι λειτουργίες αυτές δεν υλοποιούνται με το Qt, επομένως έχει πάλι δημιουργηθεί μια διαδικασία που
εκτελείται συνεχώς από το Qt και κάνει ελέγχους στο παρασκήνιο για εντολές εισόδου από το πληκτρολόγιο
και το χειριστήριο. Το πληκτρολόγιο στην περίπτωση αυτή επικοινωνεί με το παράθυρο αναζήτησης εφαρμογών
όπου ο χρήστης μπορεί να το ενεργοποιήσει πιέζοντας LCTRL και Space. Στην συνέχεια μπορεί να γράψει κείμενο
και να μεταβεί λίστα εφαρμογών με τα βελάκια. Αντίστοιχα, το χειριστήριο μπορεί στην λίστα εφαρμογών του
αρχικού παραθύρου της εφαρμογής να μετακινηθεί μεταξύ των εφαρμογών και να φτάσει στο input field πατώντας
το πάνω βελάκι όσο βρίσκεται στην πρώτη σειρά εφαρμογών.


\subsection{Η μέθοδος SetupUI}
Η μέθοδος SetupUI είναι από τις πρώτες μεθόδους που καλούνται από την εφαρμογή και
είναι υπεύθυνη για την δημιουργία των στοιχείων της γραφικής διεπαφής που τελικά
βλέπει ο χρήστης. Στην μέθοδο αυτή δημιουργούνται οι καρτέλες και τα πλαίσια στα
οποία θα προστεθούν στην συνέχεια στοιχεία όπως κουμπιά, λίστες, checkboxes, input
fields και combo boxes. Στην συνέχεια γίνεται σύνδεση των στοιχείων με τις μεθόδους
που τους αντιστοιχούν και στο τέλος δημιουργείται επίσης το παράθυρο και η γραφική
διεπαφή του παραθύρου αναζήτησης εφαρμογών πληκτρολογίου.



\subsection{Η μέθοδος ShowCustomContextMenu}
Η μέθοδος αυτή δημιουργεί ένα context menu στο επιλεγμένο στοιχείο της εφαρμογής και
το εμφανίζει όταν γίνει ένα δεξί κλικ από τον χρήστη πάνω σε αυτό. Οι λειτουργίες που
περιλαμβάνει είναι η χειροκίνητη προσθήκη κάποιας εφαρμογής που δεν υπάρχει σε κάποιο
από τα directories που έδωσε ο χρήστης στο πρόγραμμα. Η προσθήκη αυτή γίνεται στην
λίστα με τα directories όπως αναφέρθηκε προηγουμένως. Η δεύτερη ενέργεια που μπορεί
να γίνει από το context menu είναι η προσθήκη/αφαίρεση μιας εφαρμογής στην λίστα των
αγαπημένων εφαρμογών του χρήστη. Η λειτουργία αυτή προσαρμόζεται ανάλογα με την κατάσταση
μιας εφαρμογής (αγαπημένη ή όχι).

\subsection{Η μέθοδος SetupIntroScreen}
Η μέθοδος αυτή καλείται μόνο κατά την πρώτη εκτέλεση του προγράμματος και σκοπός της
είναι η δημιουργία της γραφικής διεπαφής της εισαγωγικής οθόνης στην οποία ο χρήστης
καλοσορίζεται από το πρόγραμμα και καλείται να εισάγει μερικά στοιχεία για την επιτυχή
ολοκλήρωση της αρχικοποίησης του προγράμματος. 


\subsection{Η μέθοδος UpdateUIPalette}
Η μέθοδος UpdateUIPalette δέχεται ένα string για είσοδο και στην συνέχεια
ελέγχει την τιμή του σε μία δομή επιλογής if...else if. Ανάλογα με την τιμή αυτή εφαρμόζεται
η κατάλληλη θεματολογία για τα χρώματα της εφαρμογής. Η τιμή εισόδου προέρχεται από
ένα combobox που είναι διαθέσιμο στον χρήστη στην καρτέλα ρυθμίσεων.





% VirtualKeyboard class

\section{Η κλάση VirtualKeyboard}

Η κλάση VirtualKeyboard δημιουργεί το αντικείμενο του εικονικού πληκτρολογίου και διαχειρίζεται
τα δεδομένα του. Μέσω της κλάσης αυτής ο χρήστης μπορεί να γράψει ένα κείμενο εισόδου και στην
συνέχεια να το στείλει σε ένα input field (αν χρησιμοποιεί χειριστήριο βιντεοπαιχνιδιών) ή να 
το αντιγράψει για επικόλληση μέσω του ποντικιού.  


\subsection{Ο constructor της κλάσης}
Ο constructor αυτή της κλάσης αρχικοποιεί το input field στο οποίο θα εμφανιστεί το κείμενο που
πληκτρολογεί ο χρήστης και στην συνέχεια καλεί την CreateKeyboardUI για το χτίσιμο της γραφικής
διεπαφής.


\subsection{Η μέθοδος GetWidgetAt}
Για την ανίχνευση της θέσης στην οποία βρίσκεται χρήστης στο εικονικό πληκτρολόγιο πρέπει να
ανακτηθεί το αντικείμενο το οποίο βρίσκεται στην τωρινή θέση του δείκτη. Επομένως η μέθοδος
αυτή ελέγχει όλες τις θέσεις του δισδιάστατου πλαισίου στο οποίο τοποθετούνται τα εικονικά
πλήκτρα, όπου στην προκειμένη περίπτωση υλοποιούνται ως κουμπιά, ανακτά το αντικείμενο που
βρίσκεται στην θέση αυτή -----------------------------

\subsection{Η μέθοδος SendKeyboardInput}
Η μέθοδος SendKeyboardInput καλείται από το χειριστήριο για την εισαγωγή και αποστολή κειμένου
από το εικονικό πληκτρολόγιο προς το ενεργό input field. Αυτό που κάνει είναι να κρατάει το
τελευταίο ενεργό παράθυρο και στην συνέχεια να φέρνει στο προσκήνιο το παράθυρο του εικονικού
πληκτρολογίου. Κατά την διάρκεια κλήσης της SendKeyboardInput γίνεται έλεγχος για τα κουμπιά
που πιέζονται από τον χρήστη ώστε να ενημερωθεί η γραφική διεπαφή του πληκτρολογίου και να
εμφανιστεί η θέση στην οποία βρίσκεται ο χρήστης πάνω στο πληκτρολόγιο. Όταν ο χρήστης τελειώσει
και πιέσει το κουμπί "Start" του χειριστηρίου το παράθυρο του πληκτρολογίου κρύβεται και στο
προσκήνιο εμφανίζεται το τελευταίο παράθυρο που κράτησε η εφαρμογή. Τέλος στέλνεται το input
στο παράθυρο και εισάγεται στο input field.



\subsection{Η μέθοδος CreateKeyboardUI}

Η μέθοδος αυτή είναι υπεύθυνη για την δημιουργία της γραφικής διεπαφής του εικονικού πληκτρολογίου.
Αρχικά δημιουργεί τα απαραίτητα πλαίσια και στην συνέχεια προσθέτει τα κατάλληλα κουμπιά με βάση
έναν πίνακα που περιλαμβάνει το σχέδιο του πληκτρολογίου. Το σχήμα του UI είναι βασισμένο στο
σχήμα πληκτρολογίου QWERTY.



\section{Η ροή του προγράμματος}
Γνωρίζοντας πλέον τα σημαντικά κομμάτια που απαρτίζουν την εφαρμογή, μπορούμε πλέον να περιγράψουμε
με ποιο τρόπο συνδυάζονται για την παραγωγή του τελικού αποτελέσματος. Για να μπορέσουμε να καταλάβουμε
καλύτερα την ροή του προγράμματος θα γίνει περιγραφή με κώδικα όπου θα εξηγείται η σειρά εκτέλεσης
των εντολών και των μεθόδων αγνοώντας τις λεπτομέρειες και εστιάζοντας στην πλήρη εικόνα. Ξεκινώντας
λοιπόν από την συνάρτηση main έχουμε την δημιουργία του αντικειμένου "app" της εφαρμογής. Στην συνέχεια
δημιουργείται το ApplicationExplorer αντικείμενο "περνώντας" στον constructor του το αντικείμενο της 
εφαρμογής. Αυτό θα επιτρέψει στην κλάση να διαχειριστεί την εφαρμογή και πρακτικά θα το αξιοποιήσει
στην αλλαγή της παλέτας της γραφικής διεπαφής για την αλλαγή της θεματολογίας. 
\begin{lstlisting}[language=C++, style=cppstyle]
int main(int argc, char* argv[]) 
{
    QApplication app(argc, argv);
    
    ApplicationExplorer explorer(app);
    // ....
    

    return app.exec();
}
\end{lstlisting}

Με την κλήση του constructor έχουμε την αρχικοποίηση του χρονικού διαστήματος που ορίζεται για το
χειριστήριο και συνδέεται με την μέθοδο TaskGamepadConnection.

\begin{lstlisting}[language=C++, style=cppstyle]
ApplicationExplorer(QApplication& app, QWidget* parent = nullptr) : QWidget(parent), app(app)
{
    timer = new QTimer(this);
    connect(timer, &QTimer::timeout, this, &ApplicationExplorer::TaskGamepadConnection);
    timer->start();
}
\end{lstlisting}

Επιστρέφοντας στην main, ορίζονται κάποια χαρακτηριστικά στο παράθυρο της εφαρμογής και στην συνέχεια
ανακτάται η ανάλυση της οθόνης. Γνωρίζοντας πλέον την ανάλυση της οθόνης, η εφαρμογή είναι σε θέση να
δημιουργήσει τα στοιχεία της γραφικής διεπαφής των οποίων το μέγεθος είναι σχετικό της ανάλυσης.

\begin{lstlisting}[language=C++, style=cppstyle]
int main(int argc, char* argv[]) 
{
    QApplication app(argc, argv);
    
    // ...
    
    explorer.setWindowTitle("P2019140 - Konstantinos Tourtsakis");
    explorer.setWindowFlags(Qt::WindowCloseButtonHint | Qt::FramelessWindowHint);
    explorer.resize(800, 600);

    // Storing screen resolution
    screen_width = GetSystemMetrics(SM_CXSCREEN);
    screen_height = GetSystemMetrics(SM_CYSCREEN);
    //std::cout << "Screen resolution: " << screen_width << "x" << screen_height << std::endl;

    explorer.CreateUI();

    // ...

    
    return app.exec();
}
\end{lstlisting}

Για τον σκοπό αυτό καλείται η μέθοδος CreateUI. Στην μέθοδο αυτή γίνεται αρχικά έλεγχος για την
πρώτη εκτέλεση του προγράμματος μετά την φόρτωση των δεδομένων της εφαρμογής από τον δίσκο. Αν
είναι η πρώτη φορά εκτέλεσης του προγράμματος τότε το γραφικό περιβάλλον που δημιουργείται έχει
στόχο την εισαγωγή και το καλωσόρισμα του χρήστη στην εφαρμογή. Με την ολοκλήρωση των απαραίτητων
ενεργειών που ζητούνται από το πρόγραμμα, ο χρήστης στην συνέχεια εισέρχεται στην γραφική διεπαφή
του προγράμματος. Αυτό συμβαίνει αφού κληθεί για δεύτερη φορά η CreateUI από την SetupIntroScreen
όπου πλέον η εφαρμογή γνωρίζει πως δεν είναι η πρώτη εκτέλεση που συμβαίνει και καλεί την SetupUI.

\begin{lstlisting}[language=C++, style=cppstyle]
void CreateUI() 
{
    LoadAppData();
    
    if (is_first_launch)
    {
        SetupIntroScreen();
    }
    else
    {
        SetupUI();
    }
}
\end{lstlisting}

Πίσω στην συνάρτηση main, γίνεται δημιουργία του εικονικού πληκτρολογίου και η κλήση του constructor
του. Στην συνέχεια ακολουθεί ο ορισμός κάποιων χαρακτηριστικών στο παράθυρο του πληκτρολογίου και 
μετά γίνεται αποθήκευση της διεύθυνσής του στο αντικείμενο της κλάσης ApplicationExplorer η οποία
το διαχειρίζεται για την επικοινωνία του με την εφαρμογή.

\begin{lstlisting}[language=C++, style=cppstyle]
int main(int argc, char* argv[]) 
{
    QApplication app(argc, argv);
    
    // ...
    VirtualKeyboard QKeyboard;

    //QKeyboard.setWindowFlags(Qt::WindowCloseButtonHint | Qt::FramelessWindowHint);
    explorer.QKeyboard = &QKeyboard;
    // ...

    
    return app.exec();
}
\end{lstlisting}

Ρίχνοντας μια ματιά στον constructor της VirtualKeyboard, μπορούμε να δούμε πως το πρόγραμμα ουσιαστικά
συνεχίζει με την δημιουργία της γραφικής του διεπαφής.

\begin{lstlisting}[language=C++, style=cppstyle]
VirtualKeyboard()
{
    setWindowTitle("Virtual Keyboard");
    virtual_input = new QLineEdit(this);
    virtual_input->setReadOnly(true);
    virtual_input->setPlaceholderText("Your input");
    CreateKeyboardUI();
}
\end{lstlisting}

Όπως φαίνεται παρακάτω, για την δημιουργία της γραφικής διεπαφής γίνεται χρήση κουμπιών που δημιουργούνται
σύμφωνα με τον πίνακα πλήκτρων. Στην συνέχεια προστίθενται μερικά ακόμη κουμπιά και τέλος γίνεται έλεγχος 
από τον οποίο η εφαρμογή γνωρίζει εάν το πληκτρολόγιο χρησιμοποιείται από το χειριστήριο ή από το ποντίκι,
όπου στην συνέχεια φροντίζει για την προβολή διαφορετικού μηνύματος προς τις οδηγίες του χρήστη.

\begin{lstlisting}[language=C++, style=cppstyle]
void CreateKeyboardUI()
{
    
    // ....
    
    const QStringList UpperKeyLayout
    {
        "!", "@", "#", "$", "%", "^", "&", "*", "(", ")",
        "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P",
        "A", "S", "D", "F", "G", "H", "J", "K", "L", "_",
        "Z", "X", "C", "V", "B", "N", "M", "<", ">", "?",
    };

    // ....
    
    for (const QString& text : KeyLayout)
    {
        QPushButton* button = new QPushButton(text);
        
        // ....

        layout_keyboard->addWidget(button, row, column);

        // ...
    }
    
    
    QPushButton* button_back = new QPushButton("Backspace");
    
    // ....

    connect(button_back, &QPushButton::clicked, this, [=]()
        {
            virtual_input->backspace();
        });
    
    // ....
    
    column = 0;
    row++;


    layout_keyboard->addWidget(button_back, row, column);
    
    // ....

    if (getting_input)
    {
        label_instructions = new QLabel("A: type key   Y: insert space   X: Backspace   Start: send input", this);
    }
    else
    {
        label_instructions = new QLabel("Click on the keys and then use the copy button to save input to clipboard", this);
    }
    
    // ....
}
\end{lstlisting}

Επιστρέφοντας στην main, γίνεται τελικά η προβολή της γραφικής διεπαφής του προγράμματος και στην συνέχεια
ξεκινάει η βασική επανάληψη της εφαρμογής που την διαχειρίζεται το Qt. Αυτό περιλαμβάνει και όλες τις διαδικασίες
που εκτελούνται συνεχώς και τις οποίες θα δούμε στην συνέχεια.

\begin{lstlisting}[language=C++, style=cppstyle]
int main(int argc, char* argv[]) 
{
    QApplication app(argc, argv);
    
    // ....

    explorer.showMaximized();
    return app.exec();
}
\end{lstlisting}


\section{Οι επαναληπτικές διαδικασίες στο παρασκήνιο}

Όπως προαναφέρθηκε, το πρόγραμμα στηρίζεται αρκετά σε διαδικασίες που εκτελούνται στο παρασκήνιο
οι οποίες διαχειρίζονται εντολές εισόδου του χειριστηρίου και του πληκτρολογίου. Αυτές οι διαδικασίες
καλούνται συνεχώς από το Qt και είναι απαραίτητες για την σωστή λειτουργία της εφαρμογής. 

\subsection{Η συνάρτηση GamepadInputChecks}
Στο παρασκήνιο λοιπόν έχουμε την συνάρτηση GamepadInputChecks η οποία ελέγχει τις πιέσεις κουμπιών στο χειριστήριο 
βιντεοπαιχνιδιών. Η συνάρτηση αυτή αξιοποιεί μεθόδους της κλάσης XBOXController για τους ελέγχους και
συναρτήσεις που έχουν υλοποιηθεί για την αποστολή εικονικών εντολών εισόδου προς το σύστημα. Παρακάτω
βλέπουμε την κλήση της συνάρτησης SimulateKey η οποία στέλνει στο σύστημα μια εντολή εισόδου του πλήκτρου
που δέχεται ως παράμετρο.

\begin{lstlisting}[language=C++, style=cppstyle]
void GamepadInputChecks()
{
    // ....

    if (user->IsButtonJustDown(GAMEPAD_START))
    {
        SimulateKey(VK_RETURN);
    }

    // ....
}
\end{lstlisting}

Η συνάρτηση αυτή περιλαμβάνει επίσης κλήσεις συναρτήσεων που έχουν δημιουργηθεί για την αποστολή εισόδου
συντομεύσεων αλλά και την μετακίνηση του κέρσορα.


\begin{lstlisting}[language=C++, style=cppstyle]
void CursorNavigation()
{
    POINT cursor_pos;
    GetCursorPos(&cursor_pos);

    // ....
    
    if (lengthsq > dead_zone * dead_zone)
    {
        // Υπολογισμός τοποθεσίας μετακίνησης κέρσορα
    }
    else
    {
        rest_cursor = GetTickCount() + 500;
    }

    // ....

    SetCursorPos((int)x, (int)y);
}
\end{lstlisting}

\subsection{Η μέθοδος TaskHandleDevicesUICommunication}
Επιστρέφοντας στην μέθοδο TaskHandleDevicesUICommunication, παρακάτω βλέπουμε πλέον την γενική μορφή αυτής της μεθόδου.
Υπενθυμίζεται πως αυτή η μέθοδος είναι υπεύθυνη για ελέγχους εντολών εισόδου που αφορούν την επικοινωνία μεταξύ
του χειριστηρίου και της εφαρμογής αλλά και τους πληκτρολογίου με το παράθυρο αναζήτησης εφαρμογών.




\begin{lstlisting}[language=C++, style=cppstyle]
void TaskHandleDevicesUICommunication()
{
    // Handling keyboard application launcher window hardware - software communication
    if (IsKeyDown(VK_CONTROL) && IsKeyJustDown(VK_SPACE))
    {
        if (qwid_usearch_window.isVisible())
        {
            qwid_usearch_window.hide();
        }
        else
        {
            qwid_usearch_window.show();
            // ....
        }

        return;
    }

    // ....

    // Focus on the applications list with a controller
    if (user->IsButtonJustDown(GAMEPAD_DPAD_DOWN) && line_all_search->hasFocus())
    {
        list_widget->setFocus();
    }

    // ...
}
\end{lstlisting}

